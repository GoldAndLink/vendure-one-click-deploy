{"ast":null,"code":"// src/index.ts\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\n\n// src/cellselection.ts\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport { NodeSelection as NodeSelection2, Selection, SelectionRange, TextSelection } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */new WeakMap();\n  readFromCache = key => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = key => {\n    for (let i = 0; i < cache.length; i += 2) if (cache[i] == key) return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos) continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return {\n        left,\n        top,\n        right,\n        bottom\n      };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    const {\n      left,\n      right,\n      top,\n      bottom\n    } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0;; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\") throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table),\n    height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0;; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n      if (i == rowNode.childCount) break;\n      const cellNode = rowNode.child(i);\n      const {\n        colspan,\n        rowspan,\n        colwidth\n      } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;else (problems || (problems = [])).push({\n            type: \"collision\",\n            row,\n            pos,\n            n: colspan - w\n          });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2,\n              prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n    if (missing) (problems || (problems = [])).push({\n      type: \"missing\",\n      row,\n      n: missing\n    });\n    pos++;\n  }\n  if (width === 0 || height === 0) (problems || (problems = [])).push({\n    type: \"zero_sized\"\n  });\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2) if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan) for (let j = 0; j < row; j++) {\n      const prevRow = table.child(j);\n      for (let i = 0; i < prevRow.childCount; i++) {\n        const cell = prevRow.child(i);\n        if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n      }\n    }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n    if (width == -1) width = rowWidth;else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth)) (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated) map.problems.unshift({\n      type: \"colwidth mismatch\",\n      pos,\n      colwidth: updated\n    });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n  return result;\n}\n\n// src/util.ts\nimport { PluginKey } from \"prosemirror-state\";\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map(s => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth) attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter) setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: {\n      default: 1\n    },\n    rowspan: {\n      default: 1\n    },\n    colwidth: {\n      default: null\n    }\n  };\n  for (const prop in extraAttrs) cellAttrs[prop] = {\n    default: extraAttrs[prop].default\n  };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{\n        tag: \"table\"\n      }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{\n        tag: \"tr\"\n      }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [{\n        tag: \"td\",\n        getAttrs: dom => getCellAttrs(dom, extraAttrs)\n      }],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [{\n        tag: \"th\",\n        getAttrs: dom => getCellAttrs(dom, extraAttrs)\n      }],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name],\n        role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--) if ($pos.node(d).type.spec.tableRole == \"row\") return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\") return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--) if ($head.node(d).type.spec.tableRole == \"row\") return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  const result = {\n    ...attrs,\n    colspan: attrs.colspan - n\n  };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some(w => w > 0)) result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  const result = {\n    ...attrs,\n    colspan: attrs.colspan + n\n  };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++) if (table.nodeAt(map.map[col + row * map.width]).type != headerCell) return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class _CellSelection extends Selection {\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween($anchorCell.pos - tableStart, $headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter(p => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map(pos => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(doc.resolve(from), doc.resolve(from + cell.content.size));\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection()) return _CellSelection.rowSelection($anchorCell, $headCell);else if (tableChanged && this.isColSelection()) return _CellSelection.colSelection($anchorCell, $headCell);else return new _CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart);\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(`Could not create cell with attrs ${JSON.stringify(attrs)}`);\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n  replace(tr, content = Slice.empty) {\n    const mapFrom = tr.steps.length,\n      ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const {\n          $from,\n          $to\n        } = ranges[i],\n        mapping = tr.mapping.slice(mapFrom);\n      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n    }\n    const sel = Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);\n    if (sel) tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart));\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0) $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height) $headCell = doc.resolve(tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]);\n    } else {\n      if (headRect.top > 0) $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height) $anchorCell = doc.resolve(tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]);\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0) $anchorCell = doc.resolve(tableStart + map.map[anchorRect.top * map.width]);\n      if (headRect.right < map.width) $headCell = doc.resolve(tableStart + map.map[map.width * (headRect.top + 1) - 1]);\n    } else {\n      if (headRect.left > 0) $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width) $anchorCell = doc.resolve(tableStart + map.map[map.width * (anchorRect.top + 1) - 1]);\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new _CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new _CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nSelection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class _CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor),\n      $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell)) return new CellSelection($anchorCell, $headCell);else return Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(Decoration.node(pos, pos + node.nodeSize, {\n      class: \"selectedCell\"\n    }));\n  });\n  return DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({\n  $from,\n  $to\n}) {\n  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++) if ($from.after(depth + 1) < $from.end(depth)) break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--) if ($to.before(d + 1) > $to.start(d)) break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({\n  $from,\n  $to\n}) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount,\n    curSize = cur.childCount;\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    const child = cur.child(i);\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child)) changedDescendants(old.child(j), child, offset + 1, f);else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\") tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState) state.doc.descendants(check);else if (oldState.doc != state.doc) changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(attrs, attrs.colspan - prob.n, prob.n));\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    } else if (prob.type == \"zero_sized\") {\n      const pos = tr.mapping.map(tablePos);\n      tr.delete(pos, pos + table.nodeSize);\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++) if (mustAdd[i]) {\n    if (first == null) first = i;\n    last = i;\n  }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node) nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, {\n    fixTables: true\n  });\n}\n\n// src/input.ts\nimport { keydownHandler } from \"prosemirror-keymap\";\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\nimport { Selection as Selection2, TextSelection as TextSelection3 } from \"prosemirror-state\";\n\n// src/commands.ts\nimport { Fragment as Fragment2, Slice as Slice2 } from \"prosemirror-model\";\nimport { TextSelection as TextSelection2 } from \"prosemirror-state\";\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart) : map.findCell($pos.pos - tableStart);\n  return {\n    ...rect,\n    tableStart,\n    map,\n    table\n  };\n}\nfunction addColumn(tr, {\n  map,\n  tableStart,\n  table\n}, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map.colCount(pos)));\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, {\n  map,\n  table,\n  tableStart\n}, col) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height;) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(attrs, col - map.colCount(pos)));\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n    for (let i = rect.right - 1;; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++) if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell) return false;\n  return true;\n}\nfunction addRow(tr, {\n  map,\n  tableStart,\n  table\n}, row) {\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow)) refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node) cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, {\n  map,\n  table,\n  tableStart\n}, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  const seen = /* @__PURE__ */new Set();\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (seen.has(pos)) continue;\n    seen.add(pos);\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.height && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create({\n        ...attrs,\n        rowspan: cell.attrs.rowspan - 1\n      }, cell.content);\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state),\n      tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n    for (let i = rect.bottom - 1;; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({\n  width,\n  height,\n  map\n}, rect) {\n  let indexTop = rect.top * width + rect.left,\n    indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left,\n    indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1]) return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width]) return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) return false;\n  const rect = selectedRect(state),\n    {\n      map\n    } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = Fragment2.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell) continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, rect.right - rect.left - mergedCell.attrs.colspan),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({\n    node\n  }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = {\n        ...baseAttrs,\n        rowspan: 1\n      };\n      if (baseAttrs.colspan > 1) baseAttrs = {\n        ...baseAttrs,\n        colspan: 1\n      };\n      const rect = selectedRect(state),\n        tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++) attrs.push(colwidth ? {\n        ...baseAttrs,\n        colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n      } : baseAttrs);\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({\n            node: cellNode,\n            row,\n            col\n          }).createAndFill(attrs[i]));\n        }\n      }\n      tr.setNodeMarkup(cellPos, getCellType({\n        node: cellNode,\n        row: rect.top,\n        col: rect.left\n      }), attrs[0]);\n      if (sel instanceof CellSelection) tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), lastCell ? tr.doc.resolve(lastCell) : void 0));\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection) state.selection.forEachCell((node, pos) => {\n        if (node.attrs[name] !== value) tr.setNodeMarkup(pos, null, {\n          ...node.attrs,\n          [name]: value\n        });\n      });else tr.setNodeMarkup($cell.pos, null, {\n        ...$cell.nodeAfter.attrs,\n        [name]: value\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state),\n        tr = state.tr;\n      const cells = rect.map.cellsInRect(type == \"column\" ? {\n        left: rect.left,\n        top: 0,\n        right: rect.right,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: 0,\n        top: rect.top,\n        right: rect.map.width,\n        bottom: rect.bottom\n      } : rect);\n      const nodes = cells.map(pos => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++) if (nodes[i].type == types.header_cell) tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs);\n      if (tr.steps.length == 0) for (let i = 0; i < cells.length; i++) tr.setNodeMarkup(rect.tableStart + cells[i], types.header_cell, nodes[i].attrs);\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || {\n    useDeprecatedLogic: false\n  };\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state),\n        tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\"column\", rect, types);\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach(relativeCellPos => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(state.tr.setSelection(TextSelection2.between($cell, moveCellForward($cell))).scrollIntoView());\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch) dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());\n      return true;\n    }\n  }\n  return false;\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent)) tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new Slice2(baseContent, 0, 0));\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n  return true;\n}\n\n// src/copypaste.ts\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nfunction pastedCells(slice) {\n  if (!slice.size) return null;\n  let {\n    content,\n    openStart,\n    openEnd\n  } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema,\n    rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right) cells = fitSlice(tableNodeTypes(schema).row, new Slice3(cells, left, right)).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice3(content, openStart, openEnd)).content : content);\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const {\n        rowspan,\n        colspan\n      } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++) widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment3.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment3.from(cells));\n    }\n  }\n  return {\n    height: rows.length,\n    width,\n    rows\n  };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells({\n  width,\n  height,\n  rows\n}, newWidth, newHeight) {\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row],\n        cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth) cell = cell.type.createChecked(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++) added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment3.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [],\n        source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight) cell = cell.type.create({\n          ...cell.attrs,\n          rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n        }, cell.content);\n        cells.push(cell);\n      }\n      newRows.push(Fragment3.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return {\n    width,\n    height,\n    rows\n  };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell) add = empty || (empty = types.cell.createAndFill());else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++) cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill()));\n    }\n    const emptyRow = types.row.create(null, Fragment3.from(cells)),\n      rows = [];\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col,\n      pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const {\n        top: cellTop,\n        left: cellLeft\n      } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)), cell.type.createAndFill({\n        ...cell.attrs,\n        rowspan: cellTop + cell.attrs.rowspan - top\n      }));\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left,\n      pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));\n      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)));\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const {\n    top,\n    left\n  } = rect;\n  const right = left + cells.width,\n    bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table),\n      to = map.positionAt(row, right, table);\n    tr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart), new Slice3(cells.rows[row - top], 0, 0));\n  }\n  recomp();\n  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.positionAt(top, left, table)), tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))));\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = keydownHandler({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(state, dispatch, Selection2.near(sel.$headCell, dir));\n    }\n    if (axis != \"horiz\" && !sel.empty) return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(state, dispatch, Selection2.near(state.doc.resolve(sel.head + dir), dir));\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next) newSel = Selection2.near($next, 1);else if (dir < 0) newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);else newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(state, dispatch, new CellSelection(cellSel.$anchorCell, $head));\n  };\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc,\n    $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells) cells = {\n      width: 1,\n      height: 1,\n      rows: [Fragment4.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))]\n    };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start);\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(view.state, view.dispatch, start, TableMap.get($cell.node(-1)).findCell($cell.pos - start), cells);\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting) $head = $anchor2;else return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null) view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2) return stop();\n    }\n    if ($anchor2) setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection3)) return null;\n  const {\n    $head\n  } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d),\n      index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos) return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\nimport { Decoration as Decoration2, DecorationSet as DecorationSet2 } from \"prosemirror-view\";\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, defaultCellMinWidth) {\n    this.node = node;\n    this.defaultCellMinWidth = defaultCellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.table.style.setProperty(\"--default-cell-min-width\", `${defaultCellMinWidth}px`);\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumnsOnResize(node, this.colgroup, this.table, this.defaultCellMinWidth);\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row) return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const {\n      colspan,\n      colwidth\n    } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || defaultCellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n      if (!nextDOM) {\n        const col2 = document.createElement(\"col\");\n        col2.style.width = cssWidth;\n        colgroup.appendChild(col2);\n      } else {\n        if (nextDOM.style.width != cssWidth) {\n          nextDOM.style.width = cssWidth;\n        }\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new PluginKey3(\"tableColumnResizing\");\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  defaultCellMinWidth = 100,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  const plugin = new Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        var _a, _b;\n        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;\n        const tableName = tableNodeTypes(state.schema).table.name;\n        if (View && nodeViews) {\n          nodeViews[tableName] = (node, view) => {\n            return new View(node, defaultCellMinWidth, view);\n          };\n        }\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: state => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? {\n          class: \"resize-cursor\"\n        } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(view, event, handleWidth, lastColumnResizable);\n        },\n        mouseleave: view => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);\n        }\n      },\n      decorations: state => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class _ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null) return new _ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0) return new _ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new _ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, lastColumnResizable) {\n  if (!view.editable) return;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState) return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const {\n        left,\n        right\n      } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth) cell = edgeCell(view, event, \"left\", handleWidth);else if (right - event.clientX <= handleWidth) cell = edgeCell(view, event, \"right\", handleWidth);\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  if (!view.editable) return;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging) updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {\n  var _a;\n  if (!view.editable) return false;\n  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging) return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, {\n    setDragging: {\n      startX: event.clientX,\n      startWidth: width\n    }\n  }));\n  function finish(event2) {\n    win.removeEventListener(\"mouseup\", finish);\n    win.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(view, pluginState2.activeHandle, draggedWidth(pluginState2.dragging, event2, cellMinWidth));\n      view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, {\n        setDragging: null\n      }));\n    }\n  }\n  function move(event2) {\n    if (!event2.which) return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2) return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(view, pluginState2.activeHandle, dragged, defaultCellMinWidth);\n    }\n  }\n  displayColumnWidth(view, pluginState.activeHandle, width, defaultCellMinWidth);\n  win.addEventListener(\"mouseup\", finish);\n  win.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, {\n  colspan,\n  colwidth\n}) {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth,\n    parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++) if (colwidth[i]) {\n      domWidth -= colwidth[i];\n      parts--;\n    }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\") target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY\n  });\n  if (!found) return -1;\n  const {\n    pos\n  } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == \"right\") return $cell.pos;\n  const map = TableMap.get($cell.node(-1)),\n    start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, resizeMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(resizeMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, {\n    setHandle: value\n  }));\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1),\n    map = TableMap.get(table),\n    start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, {\n      ...attrs,\n      colwidth\n    });\n  }\n  if (tr.docChanged) view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, defaultCellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1),\n    start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom) return;\n  updateColumnsOnResize(table, dom.firstChild, dom, defaultCellMinWidth, col, width);\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  var _a;\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet2.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width;\n    if ((col == map.width - 1 || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      if ((_a = columnResizingPluginKey.getState(state)) == null ? void 0 : _a.dragging) {\n        decorations.push(Decoration2.node(start + cellPos, start + cellPos + table.nodeAt(cellPos).nodeSize, {\n          class: \"column-resize-dragging\"\n        }));\n      }\n      decorations.push(Decoration2.widget(pos, dom));\n    }\n  }\n  return DecorationSet2.create(state.doc, decorations);\n}\n\n// src/index.ts\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new Plugin2({\n    key: tableEditingKey,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        const {\n          deleted,\n          pos\n        } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);\n    }\n  });\n}\nexport { CellBookmark, CellSelection, ResizeState, TableMap, TableView, clipCells as __clipCells, insertCells as __insertCells, pastedCells as __pastedCells, addColSpan, addColumn, addColumnAfter, addColumnBefore, addRow, addRowAfter, addRowBefore, cellAround, cellNear, colCount, columnIsHeader, columnResizing, columnResizingPluginKey, deleteCellSelection, deleteColumn, deleteRow, deleteTable, findCell, fixTables, fixTablesKey, goToNextCell, handlePaste, inSameTable, isInTable, mergeCells, moveCellForward, nextCell, pointsAtCell, removeColSpan, removeColumn, removeRow, rowIsHeader, selectedRect, selectionCell, setCellAttr, splitCell, splitCellWithType, tableEditing, tableEditingKey, tableNodeTypes, tableNodes, toggleHeader, toggleHeaderCell, toggleHeaderColumn, toggleHeaderRow, updateColumnsOnResize };","map":{"version":3,"names":["Plugin","Plugin2","Fragment","Slice","NodeSelection","NodeSelection2","Selection","SelectionRange","TextSelection","Decoration","DecorationSet","readFromCache","addToCache","WeakMap","cache","key","get","value","set","cacheSize","cachePos","i","length","TableMap","constructor","width","height","map","problems","findCell","pos","curPos","left","top","right","bottom","j","RangeError","colCount","nextCell","axis","dir","rectBetween","a","b","leftA","rightA","topA","bottomA","leftB","rightB","topB","bottomB","Math","min","max","cellsInRect","rect","result","seen","row","col","index","push","positionAt","table","rowStart","rowEnd","child","nodeSize","rowEndIndex","computeMap","type","spec","tableRole","name","findWidth","childCount","mapPos","colWidths","e","rowNode","cellNode","colspan","rowspan","colwidth","attrs","h","n","start","w","colW","widthIndex","prev","expectedPos","missing","tableMap","badWidths","findBadColWidths","hasRowSpan","rowWidth","prevRow","cell","node","nodeAt","updated","colWidth","freshColWidth","unshift","slice","PluginKey","getCellAttrs","dom","extraAttrs","widthAttr","getAttribute","widths","test","split","s","Number","prop","getter","getFromDOM","setCellAttrs","join","setter","setDOMAttr","tableNodes","options","cellAttributes","cellAttrs","default","content","isolating","group","tableGroup","parseDOM","tag","toDOM","table_row","table_cell","cellContent","getAttrs","table_header","tableNodeTypes","schema","cached","nodes","role","tableEditingKey","cellAround","$pos","d","depth","resolve","before","cellWrapping","isInTable","state","$head","selection","selectionCell","sel","$anchorCell","$headCell","$anchor","$cell","cellNear","head","after","nodeAfter","firstChild","doc","nodeBefore","lastChild","pointsAtCell","parent","moveCellForward","inSameTable","$cellA","$cellB","end","tableStart","moved","removeColSpan","splice","some","addColSpan","columnIsHeader","headerCell","header_cell","CellSelection","_CellSelection","cells","filter","p","ranges","from","size","$from","$to","mapping","tableChanged","isRowSelection","rowSelection","isColSelection","colSelection","between","rows","rowContent","cellRect","extraLeft","extraRight","createAndFill","JSON","stringify","create","copy","fragment","replace","tr","empty","mapFrom","steps","findFrom","to","setSelection","replaceWith","forEachCell","f","anchorTop","headTop","anchorBottom","headBottom","anchorRect","headRect","anchorLeft","headLeft","anchorRight","headRight","eq","other","toJSON","anchor","fromJSON","json","anchorCell","headCell","getBookmark","CellBookmark","prototype","visible","jsonID","_CellBookmark","near","drawCellSelection","class","isCellBoundarySelection","afterFrom","beforeTo","isTextSelectionAcrossCells","fromCellBoundaryNode","toCellBoundaryNode","parentOffset","normalizeSelection","allowTableNodeSelection","normalize","lastCell","PluginKey2","fixTablesKey","changedDescendants","old","cur","offset","oldSize","curSize","outer","scan","sameMarkup","nodesBetween","fixTables","oldState","check","fixTable","descendants","tablePos","mustAdd","prob","setNodeMarkup","delete","first","last","add","side","insert","setMeta","keydownHandler","Fragment4","Selection2","TextSelection3","Fragment2","Slice2","TextSelection2","selectedRect","addColumn","refColumn","addColumnBefore","dispatch","addColumnAfter","removeColumn","mapStart","maps","deleteColumn","rowIsHeader","_a","addRow","rowPos","refRow","addRowBefore","addRowAfter","removeRow","nextRow","Set","has","newPos","deleteRow","isEmpty","c","isTextblock","cellsOverlapRectangle","indexTop","indexLeft","indexBottom","indexRight","mergeCells","mergedPos","mergedCell","cellPos","append","mapped","splitCell","nodeTypes","splitCellWithType","getCellType","baseAttrs","setCellAttr","deprecated_toggleHeader","types","isHeaderEnabledByType","cellPositions","toggleHeader","useDeprecatedLogic","isHeaderRowEnabled","isHeaderColumnEnabled","isHeaderEnabled","selectionStartsAt","cellsRect","newType","forEach","relativeCellPos","toggleHeaderRow","toggleHeaderColumn","toggleHeaderCell","findNextCell","indexAfter","goToNextCell","direction","scrollIntoView","deleteTable","deleteCellSelection","baseContent","docChanged","Fragment3","Slice3","Transform","pastedCells","openStart","openEnd","fitSlice","ensureRectangular","r","nodeType","clipCells","newWidth","newHeight","added","newRows","frag","createChecked","source","growTable","emptyHead","start2","header","emptyRow","isolateHorizontal","found","cellTop","cellLeft","isolateVertical","updatePos","insertCells","Error","recomp","handleKeyDown","ArrowLeft","arrow","ArrowRight","ArrowUp","ArrowDown","shiftArrow","Backspace","Delete","maybeSetSelection","view","atEndOfCell","$next","newSel","cellSel","handleTripleClick","handlePaste","_","handleMouseDown","startEvent","ctrlKey","metaKey","startDOMCell","domInCell","target","shiftKey","setCellSelection","preventDefault","cellUnderMouse","$anchor2","event","starting","getState","stop","root","removeEventListener","move","_event","addEventListener","dirStr","endOfTextblock","parentNode","nodeName","mousePos","posAtCoords","clientX","clientY","PluginKey3","Decoration2","DecorationSet2","TableView","defaultCellMinWidth","document","createElement","className","appendChild","style","setProperty","colgroup","updateColumnsOnResize","contentDOM","update","ignoreMutation","record","contains","overrideCol","overrideValue","totalWidth","fixedWidth","nextDOM","hasWidth","cssWidth","col2","nextSibling","removeChild","minWidth","columnResizingPluginKey","columnResizing","handleWidth","cellMinWidth","View","lastColumnResizable","plugin","init","_b","nodeViews","props","tableName","ResizeState","apply","attributes","pluginState","activeHandle","handleDOMEvents","mousemove","handleMouseMove","mouseleave","handleMouseLeave","mousedown","handleMouseDown2","decorations","handleDecorations","_ResizeState","dragging","action","getMeta","setHandle","setDragging","handle","editable","domCellAround","getBoundingClientRect","edgeCell","updateHandle","win","ownerDocument","defaultView","window","currentColWidth","startX","startWidth","finish","event2","pluginState2","updateColumnWidth","draggedWidth","which","dragged","displayColumnWidth","domAtPos","childNodes","domWidth","offsetWidth","parts","classList","indexOf","resizeMinWidth","mapIndex","zeroes","Array","fill","widget","tableEditing","deleted","mapResult","createSelectionBetween","appendTransaction","__clipCells","__insertCells","__pastedCells"],"sources":["/Users/peluche/Documents/NoursStuffs/CerisePeyi/dev/2k24/last/vendure-one-click-deploy/node_modules/prosemirror-tables/dist/index.js"],"sourcesContent":["// src/index.ts\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\n\n// src/cellselection.ts\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport {\n  NodeSelection as NodeSelection2,\n  Selection,\n  SelectionRange,\n  TextSelection\n} from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */ new WeakMap();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key) return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos) continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return { left, top, right, bottom };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    const { left, right, top, bottom } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0; ; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\")\n    throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table), height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n      if (i == rowNode.childCount) break;\n      const cellNode = rowNode.child(i);\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: \"collision\",\n              row,\n              pos,\n              n: colspan - w\n            });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: \"missing\", row, n: missing });\n    pos++;\n  }\n  if (width === 0 || height === 0)\n    (problems || (problems = [])).push({ type: \"zero_sized\" });\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        const prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          const cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n    if (width == -1) width = rowWidth;\n    else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: \"colwidth mismatch\",\n        pos,\n        colwidth: updated\n      });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n  return result;\n}\n\n// src/util.ts\nimport { PluginKey } from \"prosemirror-state\";\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter) setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: { default: 1 },\n    rowspan: { default: 1 },\n    colwidth: { default: null }\n  };\n  for (const prop in extraAttrs)\n    cellAttrs[prop] = { default: extraAttrs[prop].default };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: \"table\" }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{ tag: \"tr\" }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"td\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"th\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name], role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == \"row\")\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\") return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == \"row\") return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan - n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0)) result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan + n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class _CellSelection extends Selection {\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween(\n      $anchorCell.pos - tableStart,\n      $headCell.pos - tableStart\n    );\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map((pos) => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size)\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return _CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return _CellSelection.colSelection($anchorCell, $headCell);\n      else return new _CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(\n      this.$anchorCell.pos - tableStart,\n      this.$headCell.pos - tableStart\n    );\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(\n              attrs,\n              attrs.colspan - extraRight,\n              extraRight\n            );\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`\n              );\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n  replace(tr, content = Slice.empty) {\n    const mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? Slice.empty : content\n      );\n    }\n    const sel = Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1\n    );\n    if (sel) tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(\n      map.rectBetween(\n        this.$anchorCell.pos - tableStart,\n        this.$headCell.pos - tableStart\n      )\n    );\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[anchorRect.top * map.width]\n        );\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (headRect.top + 1) - 1]\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new _CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new _CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nSelection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class _CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))\n      return new CellSelection($anchorCell, $headCell);\n    else return Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" })\n    );\n  });\n  return DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({ $from, $to }) {\n  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth)) break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d)) break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount, curSize = cur.childCount;\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    const child = cur.child(i);\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child))\n      changedDescendants(old.child(j), child, offset + 1, f);\n    else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\")\n      tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState) state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)\n      );\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    } else if (prob.type == \"zero_sized\") {\n      const pos = tr.mapping.map(tablePos);\n      tr.delete(pos, pos + table.nodeSize);\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null) first = i;\n      last = i;\n    }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node) nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n\n// src/input.ts\nimport { keydownHandler } from \"prosemirror-keymap\";\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\nimport {\n  Selection as Selection2,\n  TextSelection as TextSelection3\n} from \"prosemirror-state\";\n\n// src/commands.ts\nimport {\n  Fragment as Fragment2,\n  Slice as Slice2\n} from \"prosemirror-model\";\nimport {\n  TextSelection as TextSelection2\n} from \"prosemirror-state\";\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(\n    sel.$anchorCell.pos - tableStart,\n    sel.$headCell.pos - tableStart\n  ) : map.findCell($pos.pos - tableStart);\n  return { ...rect, tableStart, map, table };\n}\nfunction addColumn(tr, { map, tableStart, table }, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs, col - map.colCount(pos))\n      );\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, { map, table, tableStart }, col) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(attrs, col - map.colCount(pos))\n      );\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)\n      return false;\n  return true;\n}\nfunction addRow(tr, { map, tableStart, table }, row) {\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node) cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, { map, table, tableStart }, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  const seen = /* @__PURE__ */ new Set();\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (seen.has(pos)) continue;\n    seen.add(pos);\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.height && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create(\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\n        cell.content\n      );\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state), tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)\n    return false;\n  const rect = selectedRect(state), { map } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = Fragment2.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell) continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(\n        mergedCell.attrs,\n        mergedCell.attrs.colspan,\n        rect.right - rect.left - mergedCell.attrs.colspan\n      ),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))\n    );\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };\n      if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };\n      const rect = selectedRect(state), tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth ? {\n            ...baseAttrs,\n            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n          } : baseAttrs\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(\n            lastCell = tr.mapping.map(pos + rect.tableStart, 1),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0]\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell ? tr.doc.resolve(lastCell) : void 0\n          )\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, {\n              ...node.attrs,\n              [name]: value\n            });\n        });\n      else\n        tr.setNodeMarkup($cell.pos, null, {\n          ...$cell.nodeAfter.attrs,\n          [name]: value\n        });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const cells = rect.map.cellsInRect(\n        type == \"column\" ? {\n          left: rect.left,\n          top: 0,\n          right: rect.right,\n          bottom: rect.map.height\n        } : type == \"row\" ? {\n          left: 0,\n          top: rect.top,\n          right: rect.map.width,\n          bottom: rect.bottom\n        } : rect\n      );\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++)\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs\n          );\n      if (tr.steps.length == 0)\n        for (let i = 0; i < cells.length; i++)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\n        \"column\",\n        rect,\n        types\n      );\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr.setSelection(TextSelection2.between($cell, moveCellForward($cell))).scrollIntoView()\n      );\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()\n        );\n      return true;\n    }\n  }\n  return false;\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new Slice2(baseContent, 0, 0)\n        );\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n  return true;\n}\n\n// src/copypaste.ts\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nfunction pastedCells(slice) {\n  if (!slice.size) return null;\n  let { content, openStart, openEnd } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema, rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new Slice3(cells, left, right)\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(\n      openStart || openEnd ? fitSlice(\n        tableNodeTypes(schema).row,\n        new Slice3(content, openStart, openEnd)\n      ).content : content\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment3.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment3.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row], cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.createChecked(\n            removeColSpan(\n              cell.attrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth\n            ),\n            cell.content\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment3.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [], source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            {\n              ...cell.attrs,\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n            },\n            cell.content\n          );\n        cells.push(cell);\n      }\n      newRows.push(Fragment3.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return { width, height, rows };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill());\n      else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++) cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(\n        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())\n      );\n    }\n    const emptyRow = types.row.create(null, Fragment3.from(cells)), rows = [];\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col, pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill({\n          ...cell.attrs,\n          rowspan: cellTop + cell.attrs.rowspan - top\n        })\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left, pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft)\n        )\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(\n          removeColSpan(cell.attrs, 0, left - cellLeft)\n        )\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const { top, left } = rect;\n  const right = left + cells.width, bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new Slice3(cells.rows[row - top], 0, 0)\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))\n    )\n  );\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = keydownHandler({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(sel.$headCell, dir)\n      );\n    }\n    if (axis != \"horiz\" && !sel.empty) return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(state.doc.resolve(sel.head + dir), dir)\n      );\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next) newSel = Selection2.near($next, 1);\n      else if (dir < 0)\n        newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);\n      else newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(cellSel.$anchorCell, $head)\n    );\n  };\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          Fragment4.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice)\n          )\n        ]\n      };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting) $head = $anchor2;\n      else return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2) return stop();\n    }\n    if ($anchor2) setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection3)) return null;\n  const { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos) return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\nimport {\n  Decoration as Decoration2,\n  DecorationSet as DecorationSet2\n} from \"prosemirror-view\";\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, defaultCellMinWidth) {\n    this.node = node;\n    this.defaultCellMinWidth = defaultCellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.table.style.setProperty(\n      \"--default-cell-min-width\",\n      `${defaultCellMinWidth}px`\n    );\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumnsOnResize(\n      node,\n      this.colgroup,\n      this.table,\n      this.defaultCellMinWidth\n    );\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row) return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const { colspan, colwidth } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || defaultCellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n      if (!nextDOM) {\n        const col2 = document.createElement(\"col\");\n        col2.style.width = cssWidth;\n        colgroup.appendChild(col2);\n      } else {\n        if (nextDOM.style.width != cssWidth) {\n          nextDOM.style.width = cssWidth;\n        }\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new PluginKey3(\n  \"tableColumnResizing\"\n);\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  defaultCellMinWidth = 100,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  const plugin = new Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        var _a, _b;\n        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;\n        const tableName = tableNodeTypes(state.schema).table.name;\n        if (View && nodeViews) {\n          nodeViews[tableName] = (node, view) => {\n            return new View(node, defaultCellMinWidth, view);\n          };\n        }\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(view, event, handleWidth, lastColumnResizable);\n        },\n        mouseleave: (view) => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);\n        }\n      },\n      decorations: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class _ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null)\n      return new _ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0)\n      return new _ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new _ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, lastColumnResizable) {\n  if (!view.editable) return;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState) return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, \"left\", handleWidth);\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, \"right\", handleWidth);\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  if (!view.editable) return;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {\n  var _a;\n  if (!view.editable) return false;\n  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\n    return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, {\n      setDragging: { startX: event.clientX, startWidth: width }\n    })\n  );\n  function finish(event2) {\n    win.removeEventListener(\"mouseup\", finish);\n    win.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        draggedWidth(pluginState2.dragging, event2, cellMinWidth)\n      );\n      view.dispatch(\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })\n      );\n    }\n  }\n  function move(event2) {\n    if (!event2.which) return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2) return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        dragged,\n        defaultCellMinWidth\n      );\n    }\n  }\n  displayColumnWidth(\n    view,\n    pluginState.activeHandle,\n    width,\n    defaultCellMinWidth\n  );\n  win.addEventListener(\"mouseup\", finish);\n  win.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth, parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY\n  });\n  if (!found) return -1;\n  const { pos } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == \"right\") return $cell.pos;\n  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, resizeMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(resizeMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })\n  );\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });\n  }\n  if (tr.docChanged) view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, defaultCellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom) return;\n  updateColumnsOnResize(\n    table,\n    dom.firstChild,\n    dom,\n    defaultCellMinWidth,\n    col,\n    width\n  );\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  var _a;\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet2.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width;\n    if ((col == map.width - 1 || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      if ((_a = columnResizingPluginKey.getState(state)) == null ? void 0 : _a.dragging) {\n        decorations.push(\n          Decoration2.node(\n            start + cellPos,\n            start + cellPos + table.nodeAt(cellPos).nodeSize,\n            {\n              class: \"column-resize-dragging\"\n            }\n          )\n        );\n      }\n      decorations.push(Decoration2.widget(pos, dom));\n    }\n  }\n  return DecorationSet2.create(state.doc, decorations);\n}\n\n// src/index.ts\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new Plugin2({\n    key: tableEditingKey,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        const { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection\n      );\n    }\n  });\n}\nexport {\n  CellBookmark,\n  CellSelection,\n  ResizeState,\n  TableMap,\n  TableView,\n  clipCells as __clipCells,\n  insertCells as __insertCells,\n  pastedCells as __pastedCells,\n  addColSpan,\n  addColumn,\n  addColumnAfter,\n  addColumnBefore,\n  addRow,\n  addRowAfter,\n  addRowBefore,\n  cellAround,\n  cellNear,\n  colCount,\n  columnIsHeader,\n  columnResizing,\n  columnResizingPluginKey,\n  deleteCellSelection,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  findCell,\n  fixTables,\n  fixTablesKey,\n  goToNextCell,\n  handlePaste,\n  inSameTable,\n  isInTable,\n  mergeCells,\n  moveCellForward,\n  nextCell,\n  pointsAtCell,\n  removeColSpan,\n  removeColumn,\n  removeRow,\n  rowIsHeader,\n  selectedRect,\n  selectionCell,\n  setCellAttr,\n  splitCell,\n  splitCellWithType,\n  tableEditing,\n  tableEditingKey,\n  tableNodeTypes,\n  tableNodes,\n  toggleHeader,\n  toggleHeaderCell,\n  toggleHeaderColumn,\n  toggleHeaderRow,\n  updateColumnsOnResize\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}