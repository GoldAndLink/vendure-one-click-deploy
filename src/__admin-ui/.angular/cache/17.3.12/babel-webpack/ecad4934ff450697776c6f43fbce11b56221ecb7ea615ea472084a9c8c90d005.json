{"ast":null,"code":"// @ts-check\n\n// @deno-types=\"is-plain-obj/index.d.ts\"\nimport isPlainObject from \"is-plain-obj\";\n\n/** @typedef {import(\"./isExtractableFile.mjs\").default} isExtractableFile */\n\n/**\n * Recursively extracts files and their {@link ObjectPath object paths} within a\n * value, replacing them with `null` in a deep clone without mutating the\n * original value.\n * [`FileList`](https://developer.mozilla.org/en-US/docs/Web/API/Filelist)\n * instances are treated as\n * [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) instance\n * arrays.\n * @template Extractable Extractable file type.\n * @param {unknown} value Value to extract files from. Typically an object tree.\n * @param {(value: unknown) => value is Extractable} isExtractable Matches\n *   extractable files. Typically {@linkcode isExtractableFile}.\n * @param {ObjectPath} [path] Prefix for object paths for extracted files.\n *   Defaults to `\"\"`.\n * @returns {Extraction<Extractable>} Extraction result.\n * @example\n * Extracting files from an object.\n *\n * For the following:\n *\n * ```js\n * import extractFiles from \"extract-files/extractFiles.mjs\";\n * import isExtractableFile from \"extract-files/isExtractableFile.mjs\";\n *\n * const file1 = new File([\"1\"], \"1.txt\", { type: \"text/plain\" });\n * const file2 = new File([\"2\"], \"2.txt\", { type: \"text/plain\" });\n * const value = {\n *   a: file1,\n *   b: [file1, file2],\n * };\n *\n * const { clone, files } = extractFiles(value, isExtractableFile, \"prefix\");\n * ```\n *\n * `value` remains the same.\n *\n * `clone` is:\n *\n * ```json\n * {\n *   \"a\": null,\n *   \"b\": [null, null]\n * }\n * ```\n *\n * `files` is a\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * instance containing:\n *\n * | Key     | Value                        |\n * | :------ | :--------------------------- |\n * | `file1` | `[\"prefix.a\", \"prefix.b.0\"]` |\n * | `file2` | `[\"prefix.b.1\"]`             |\n */\nexport default function extractFiles(value, isExtractable, path = \"\") {\n  if (!arguments.length) throw new TypeError(\"Argument 1 `value` is required.\");\n  if (typeof isExtractable !== \"function\") throw new TypeError(\"Argument 2 `isExtractable` must be a function.\");\n  if (typeof path !== \"string\") throw new TypeError(\"Argument 3 `path` must be a string.\");\n\n  /**\n   * Deeply clonable value.\n   * @typedef {Array<unknown> | FileList | {\n   *   [key: PropertyKey]: unknown\n   * }} Cloneable\n   */\n\n  /**\n   * Clone of a {@link Cloneable deeply cloneable value}.\n   * @typedef {Exclude<Cloneable, FileList>} Clone\n   */\n\n  /**\n   * Map of values recursed within the input value and their clones, for reusing\n   * clones of values that are referenced multiple times within the input value.\n   * @type {Map<Cloneable, Clone>}\n   */\n  const clones = new Map();\n\n  /**\n   * Extracted files and their object paths within the input value.\n   * @type {Extraction<Extractable>[\"files\"]}\n   */\n  const files = new Map();\n\n  /**\n   * Recursively clones the value, extracting files.\n   * @param {unknown} value Value to extract files from.\n   * @param {ObjectPath} path Prefix for object paths for extracted files.\n   * @param {Set<Cloneable>} recursed Recursed values for avoiding infinite\n   *   recursion of circular references within the input value.\n   * @returns {unknown} Clone of the value with files replaced with `null`.\n   */\n  function recurse(value, path, recursed) {\n    if (isExtractable(value)) {\n      const filePaths = files.get(value);\n      filePaths ? filePaths.push(path) : files.set(value, [path]);\n      return null;\n    }\n    const valueIsList = Array.isArray(value) || typeof FileList !== \"undefined\" && value instanceof FileList;\n    const valueIsPlainObject = isPlainObject(value);\n    if (valueIsList || valueIsPlainObject) {\n      let clone = clones.get(value);\n      const uncloned = !clone;\n      if (uncloned) {\n        clone = valueIsList ? [] :\n        // Replicate if the plain object is an `Object` instance.\n        value instanceof (/** @type {any} */Object) ? {} : Object.create(null);\n        clones.set(value, /** @type {Clone} */clone);\n      }\n      if (!recursed.has(value)) {\n        const pathPrefix = path ? `${path}.` : \"\";\n        const recursedDeeper = new Set(recursed).add(value);\n        if (valueIsList) {\n          let index = 0;\n          for (const item of value) {\n            const itemClone = recurse(item, pathPrefix + index++, recursedDeeper);\n            if (uncloned) /** @type {Array<unknown>} */clone.push(itemClone);\n          }\n        } else for (const key in value) {\n          const propertyClone = recurse(value[key], pathPrefix + key, recursedDeeper);\n          if (uncloned) /** @type {{ [key: PropertyKey]: unknown }} */clone[key] = propertyClone;\n        }\n      }\n      return clone;\n    }\n    return value;\n  }\n  return {\n    clone: recurse(value, path, new Set()),\n    files\n  };\n}\n\n/**\n * An extraction result.\n * @template [Extractable=unknown] Extractable file type.\n * @typedef {object} Extraction\n * @prop {unknown} clone Clone of the original value with extracted files\n *   recursively replaced with `null`.\n * @prop {Map<Extractable, Array<ObjectPath>>} files Extracted files and their\n *   object paths within the original value.\n */\n\n/**\n * String notation for the path to a node in an object tree.\n * @typedef {string} ObjectPath\n * @see [`object-path` on npm](https://npm.im/object-path).\n * @example\n * An object path for object property `a`, array index `0`, object property `b`:\n *\n * ```\n * a.0.b\n * ```\n */","map":{"version":3,"names":["isPlainObject","extractFiles","value","isExtractable","path","arguments","length","TypeError","clones","Map","files","recurse","recursed","filePaths","get","push","set","valueIsList","Array","isArray","FileList","valueIsPlainObject","clone","uncloned","Object","create","has","pathPrefix","recursedDeeper","Set","add","index","item","itemClone","key","propertyClone"],"sources":["/Users/peluche/Documents/NoursStuffs/CerisePeyi/dev/2k24/last/vendure-one-click-deploy/node_modules/extract-files/extractFiles.mjs"],"sourcesContent":["// @ts-check\n\n// @deno-types=\"is-plain-obj/index.d.ts\"\nimport isPlainObject from \"is-plain-obj\";\n\n/** @typedef {import(\"./isExtractableFile.mjs\").default} isExtractableFile */\n\n/**\n * Recursively extracts files and their {@link ObjectPath object paths} within a\n * value, replacing them with `null` in a deep clone without mutating the\n * original value.\n * [`FileList`](https://developer.mozilla.org/en-US/docs/Web/API/Filelist)\n * instances are treated as\n * [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) instance\n * arrays.\n * @template Extractable Extractable file type.\n * @param {unknown} value Value to extract files from. Typically an object tree.\n * @param {(value: unknown) => value is Extractable} isExtractable Matches\n *   extractable files. Typically {@linkcode isExtractableFile}.\n * @param {ObjectPath} [path] Prefix for object paths for extracted files.\n *   Defaults to `\"\"`.\n * @returns {Extraction<Extractable>} Extraction result.\n * @example\n * Extracting files from an object.\n *\n * For the following:\n *\n * ```js\n * import extractFiles from \"extract-files/extractFiles.mjs\";\n * import isExtractableFile from \"extract-files/isExtractableFile.mjs\";\n *\n * const file1 = new File([\"1\"], \"1.txt\", { type: \"text/plain\" });\n * const file2 = new File([\"2\"], \"2.txt\", { type: \"text/plain\" });\n * const value = {\n *   a: file1,\n *   b: [file1, file2],\n * };\n *\n * const { clone, files } = extractFiles(value, isExtractableFile, \"prefix\");\n * ```\n *\n * `value` remains the same.\n *\n * `clone` is:\n *\n * ```json\n * {\n *   \"a\": null,\n *   \"b\": [null, null]\n * }\n * ```\n *\n * `files` is a\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * instance containing:\n *\n * | Key     | Value                        |\n * | :------ | :--------------------------- |\n * | `file1` | `[\"prefix.a\", \"prefix.b.0\"]` |\n * | `file2` | `[\"prefix.b.1\"]`             |\n */\nexport default function extractFiles(value, isExtractable, path = \"\") {\n  if (!arguments.length) throw new TypeError(\"Argument 1 `value` is required.\");\n\n  if (typeof isExtractable !== \"function\")\n    throw new TypeError(\"Argument 2 `isExtractable` must be a function.\");\n\n  if (typeof path !== \"string\")\n    throw new TypeError(\"Argument 3 `path` must be a string.\");\n\n  /**\n   * Deeply clonable value.\n   * @typedef {Array<unknown> | FileList | {\n   *   [key: PropertyKey]: unknown\n   * }} Cloneable\n   */\n\n  /**\n   * Clone of a {@link Cloneable deeply cloneable value}.\n   * @typedef {Exclude<Cloneable, FileList>} Clone\n   */\n\n  /**\n   * Map of values recursed within the input value and their clones, for reusing\n   * clones of values that are referenced multiple times within the input value.\n   * @type {Map<Cloneable, Clone>}\n   */\n  const clones = new Map();\n\n  /**\n   * Extracted files and their object paths within the input value.\n   * @type {Extraction<Extractable>[\"files\"]}\n   */\n  const files = new Map();\n\n  /**\n   * Recursively clones the value, extracting files.\n   * @param {unknown} value Value to extract files from.\n   * @param {ObjectPath} path Prefix for object paths for extracted files.\n   * @param {Set<Cloneable>} recursed Recursed values for avoiding infinite\n   *   recursion of circular references within the input value.\n   * @returns {unknown} Clone of the value with files replaced with `null`.\n   */\n  function recurse(value, path, recursed) {\n    if (isExtractable(value)) {\n      const filePaths = files.get(value);\n\n      filePaths ? filePaths.push(path) : files.set(value, [path]);\n\n      return null;\n    }\n\n    const valueIsList =\n      Array.isArray(value) ||\n      (typeof FileList !== \"undefined\" && value instanceof FileList);\n    const valueIsPlainObject = isPlainObject(value);\n\n    if (valueIsList || valueIsPlainObject) {\n      let clone = clones.get(value);\n\n      const uncloned = !clone;\n\n      if (uncloned) {\n        clone = valueIsList\n          ? []\n          : // Replicate if the plain object is an `Object` instance.\n          value instanceof /** @type {any} */ (Object)\n          ? {}\n          : Object.create(null);\n\n        clones.set(value, /** @type {Clone} */ (clone));\n      }\n\n      if (!recursed.has(value)) {\n        const pathPrefix = path ? `${path}.` : \"\";\n        const recursedDeeper = new Set(recursed).add(value);\n\n        if (valueIsList) {\n          let index = 0;\n\n          for (const item of value) {\n            const itemClone = recurse(\n              item,\n              pathPrefix + index++,\n              recursedDeeper\n            );\n\n            if (uncloned) /** @type {Array<unknown>} */ (clone).push(itemClone);\n          }\n        } else\n          for (const key in value) {\n            const propertyClone = recurse(\n              value[key],\n              pathPrefix + key,\n              recursedDeeper\n            );\n\n            if (uncloned)\n              /** @type {{ [key: PropertyKey]: unknown }} */ (clone)[key] =\n                propertyClone;\n          }\n      }\n\n      return clone;\n    }\n\n    return value;\n  }\n\n  return {\n    clone: recurse(value, path, new Set()),\n    files,\n  };\n}\n\n/**\n * An extraction result.\n * @template [Extractable=unknown] Extractable file type.\n * @typedef {object} Extraction\n * @prop {unknown} clone Clone of the original value with extracted files\n *   recursively replaced with `null`.\n * @prop {Map<Extractable, Array<ObjectPath>>} files Extracted files and their\n *   object paths within the original value.\n */\n\n/**\n * String notation for the path to a node in an object tree.\n * @typedef {string} ObjectPath\n * @see [`object-path` on npm](https://npm.im/object-path).\n * @example\n * An object path for object property `a`, array index `0`, object property `b`:\n *\n * ```\n * a.0.b\n * ```\n */\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}