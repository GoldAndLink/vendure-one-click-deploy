{"ast":null,"code":"const globalWindow = window;\nexport function CodeJar(editor, highlight, opt = {}) {\n  const options = {\n    tab: '\\t',\n    indentOn: /[({\\[]$/,\n    moveToNewLine: /^[)}\\]]/,\n    spellcheck: false,\n    catchTab: true,\n    preserveIdent: true,\n    addClosing: true,\n    history: true,\n    window: globalWindow,\n    ...opt\n  };\n  const window = options.window;\n  const document = window.document;\n  const listeners = [];\n  const history = [];\n  let at = -1;\n  let focus = false;\n  let onUpdate = () => void 0;\n  let prev; // code content prior keydown event\n  editor.setAttribute('contenteditable', 'plaintext-only');\n  editor.setAttribute('spellcheck', options.spellcheck ? 'true' : 'false');\n  editor.style.outline = 'none';\n  editor.style.overflowWrap = 'break-word';\n  editor.style.overflowY = 'auto';\n  editor.style.whiteSpace = 'pre-wrap';\n  const doHighlight = (editor, pos) => {\n    highlight(editor, pos);\n  };\n  let isLegacy = false; // true if plaintext-only is not supported\n  if (editor.contentEditable !== 'plaintext-only') isLegacy = true;\n  if (isLegacy) editor.setAttribute('contenteditable', 'true');\n  const debounceHighlight = debounce(() => {\n    const pos = save();\n    doHighlight(editor, pos);\n    restore(pos);\n  }, 30);\n  let recording = false;\n  const shouldRecord = event => {\n    return !isUndo(event) && !isRedo(event) && event.key !== 'Meta' && event.key !== 'Control' && event.key !== 'Alt' && !event.key.startsWith('Arrow');\n  };\n  const debounceRecordHistory = debounce(event => {\n    if (shouldRecord(event)) {\n      recordHistory();\n      recording = false;\n    }\n  }, 300);\n  const on = (type, fn) => {\n    listeners.push([type, fn]);\n    editor.addEventListener(type, fn);\n  };\n  on('keydown', event => {\n    if (event.defaultPrevented) return;\n    prev = toString();\n    if (options.preserveIdent) handleNewLine(event);else legacyNewLineFix(event);\n    if (options.catchTab) handleTabCharacters(event);\n    if (options.addClosing) handleSelfClosingCharacters(event);\n    if (options.history) {\n      handleUndoRedo(event);\n      if (shouldRecord(event) && !recording) {\n        recordHistory();\n        recording = true;\n      }\n    }\n    if (isLegacy && !isCopy(event)) restore(save());\n  });\n  on('keyup', event => {\n    if (event.defaultPrevented) return;\n    if (event.isComposing) return;\n    if (prev !== toString()) debounceHighlight();\n    debounceRecordHistory(event);\n    onUpdate(toString());\n  });\n  on('focus', _event => {\n    focus = true;\n  });\n  on('blur', _event => {\n    focus = false;\n  });\n  on('paste', event => {\n    recordHistory();\n    handlePaste(event);\n    recordHistory();\n    onUpdate(toString());\n  });\n  on('cut', event => {\n    recordHistory();\n    handleCut(event);\n    recordHistory();\n    onUpdate(toString());\n  });\n  function save() {\n    const s = getSelection();\n    const pos = {\n      start: 0,\n      end: 0,\n      dir: undefined\n    };\n    let {\n      anchorNode,\n      anchorOffset,\n      focusNode,\n      focusOffset\n    } = s;\n    if (!anchorNode || !focusNode) throw 'error1';\n    // If the anchor and focus are the editor element, return either a full\n    // highlight or a start/end cursor position depending on the selection\n    if (anchorNode === editor && focusNode === editor) {\n      pos.start = anchorOffset > 0 && editor.textContent ? editor.textContent.length : 0;\n      pos.end = focusOffset > 0 && editor.textContent ? editor.textContent.length : 0;\n      pos.dir = focusOffset >= anchorOffset ? '->' : '<-';\n      return pos;\n    }\n    // Selection anchor and focus are expected to be text nodes,\n    // so normalize them.\n    if (anchorNode.nodeType === Node.ELEMENT_NODE) {\n      const node = document.createTextNode('');\n      anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset]);\n      anchorNode = node;\n      anchorOffset = 0;\n    }\n    if (focusNode.nodeType === Node.ELEMENT_NODE) {\n      const node = document.createTextNode('');\n      focusNode.insertBefore(node, focusNode.childNodes[focusOffset]);\n      focusNode = node;\n      focusOffset = 0;\n    }\n    visit(editor, el => {\n      if (el === anchorNode && el === focusNode) {\n        pos.start += anchorOffset;\n        pos.end += focusOffset;\n        pos.dir = anchorOffset <= focusOffset ? '->' : '<-';\n        return 'stop';\n      }\n      if (el === anchorNode) {\n        pos.start += anchorOffset;\n        if (!pos.dir) {\n          pos.dir = '->';\n        } else {\n          return 'stop';\n        }\n      } else if (el === focusNode) {\n        pos.end += focusOffset;\n        if (!pos.dir) {\n          pos.dir = '<-';\n        } else {\n          return 'stop';\n        }\n      }\n      if (el.nodeType === Node.TEXT_NODE) {\n        if (pos.dir != '->') pos.start += el.nodeValue.length;\n        if (pos.dir != '<-') pos.end += el.nodeValue.length;\n      }\n    });\n    editor.normalize(); // collapse empty text nodes\n    return pos;\n  }\n  function restore(pos) {\n    const s = getSelection();\n    let startNode,\n      startOffset = 0;\n    let endNode,\n      endOffset = 0;\n    if (!pos.dir) pos.dir = '->';\n    if (pos.start < 0) pos.start = 0;\n    if (pos.end < 0) pos.end = 0;\n    // Flip start and end if the direction reversed\n    if (pos.dir == '<-') {\n      const {\n        start,\n        end\n      } = pos;\n      pos.start = end;\n      pos.end = start;\n    }\n    let current = 0;\n    visit(editor, el => {\n      if (el.nodeType !== Node.TEXT_NODE) return;\n      const len = (el.nodeValue || '').length;\n      if (current + len > pos.start) {\n        if (!startNode) {\n          startNode = el;\n          startOffset = pos.start - current;\n        }\n        if (current + len > pos.end) {\n          endNode = el;\n          endOffset = pos.end - current;\n          return 'stop';\n        }\n      }\n      current += len;\n    });\n    if (!startNode) startNode = editor, startOffset = editor.childNodes.length;\n    if (!endNode) endNode = editor, endOffset = editor.childNodes.length;\n    // Flip back the selection\n    if (pos.dir == '<-') {\n      [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset];\n    }\n    {\n      // If nodes not editable, create a text node.\n      const startEl = uneditable(startNode);\n      if (startEl) {\n        const node = document.createTextNode('');\n        startEl.parentNode?.insertBefore(node, startEl);\n        startNode = node;\n        startOffset = 0;\n      }\n      const endEl = uneditable(endNode);\n      if (endEl) {\n        const node = document.createTextNode('');\n        endEl.parentNode?.insertBefore(node, endEl);\n        endNode = node;\n        endOffset = 0;\n      }\n    }\n    s.setBaseAndExtent(startNode, startOffset, endNode, endOffset);\n    editor.normalize(); // collapse empty text nodes\n  }\n  function uneditable(node) {\n    while (node && node !== editor) {\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        const el = node;\n        if (el.getAttribute('contenteditable') == 'false') {\n          return el;\n        }\n      }\n      node = node.parentNode;\n    }\n  }\n  function beforeCursor() {\n    const s = getSelection();\n    const r0 = s.getRangeAt(0);\n    const r = document.createRange();\n    r.selectNodeContents(editor);\n    r.setEnd(r0.startContainer, r0.startOffset);\n    return r.toString();\n  }\n  function afterCursor() {\n    const s = getSelection();\n    const r0 = s.getRangeAt(0);\n    const r = document.createRange();\n    r.selectNodeContents(editor);\n    r.setStart(r0.endContainer, r0.endOffset);\n    return r.toString();\n  }\n  function handleNewLine(event) {\n    if (event.key === 'Enter') {\n      const before = beforeCursor();\n      const after = afterCursor();\n      let [padding] = findPadding(before);\n      let newLinePadding = padding;\n      // If last symbol is \"{\" ident new line\n      if (options.indentOn.test(before)) {\n        newLinePadding += options.tab;\n      }\n      // Preserve padding\n      if (newLinePadding.length > 0) {\n        preventDefault(event);\n        event.stopPropagation();\n        insert('\\n' + newLinePadding);\n      } else {\n        legacyNewLineFix(event);\n      }\n      // Place adjacent \"}\" on next line\n      if (newLinePadding !== padding && options.moveToNewLine.test(after)) {\n        const pos = save();\n        insert('\\n' + padding);\n        restore(pos);\n      }\n    }\n  }\n  function legacyNewLineFix(event) {\n    // Firefox does not support plaintext-only mode\n    // and puts <div><br></div> on Enter. Let's help.\n    if (isLegacy && event.key === 'Enter') {\n      preventDefault(event);\n      event.stopPropagation();\n      if (afterCursor() == '') {\n        insert('\\n ');\n        const pos = save();\n        pos.start = --pos.end;\n        restore(pos);\n      } else {\n        insert('\\n');\n      }\n    }\n  }\n  function handleSelfClosingCharacters(event) {\n    const open = `([{'\"`;\n    const close = `)]}'\"`;\n    if (open.includes(event.key)) {\n      preventDefault(event);\n      const pos = save();\n      const wrapText = pos.start == pos.end ? '' : getSelection().toString();\n      const text = event.key + wrapText + close[open.indexOf(event.key)];\n      insert(text);\n      pos.start++;\n      pos.end++;\n      restore(pos);\n    }\n  }\n  function handleTabCharacters(event) {\n    if (event.key === 'Tab') {\n      preventDefault(event);\n      if (event.shiftKey) {\n        const before = beforeCursor();\n        let [padding, start] = findPadding(before);\n        if (padding.length > 0) {\n          const pos = save();\n          // Remove full length tab or just remaining padding\n          const len = Math.min(options.tab.length, padding.length);\n          restore({\n            start,\n            end: start + len\n          });\n          document.execCommand('delete');\n          pos.start -= len;\n          pos.end -= len;\n          restore(pos);\n        }\n      } else {\n        insert(options.tab);\n      }\n    }\n  }\n  function handleUndoRedo(event) {\n    if (isUndo(event)) {\n      preventDefault(event);\n      at--;\n      const record = history[at];\n      if (record) {\n        editor.innerHTML = record.html;\n        restore(record.pos);\n      }\n      if (at < 0) at = 0;\n    }\n    if (isRedo(event)) {\n      preventDefault(event);\n      at++;\n      const record = history[at];\n      if (record) {\n        editor.innerHTML = record.html;\n        restore(record.pos);\n      }\n      if (at >= history.length) at--;\n    }\n  }\n  function recordHistory() {\n    if (!focus) return;\n    const html = editor.innerHTML;\n    const pos = save();\n    const lastRecord = history[at];\n    if (lastRecord) {\n      if (lastRecord.html === html && lastRecord.pos.start === pos.start && lastRecord.pos.end === pos.end) return;\n    }\n    at++;\n    history[at] = {\n      html,\n      pos\n    };\n    history.splice(at + 1);\n    const maxHistory = 300;\n    if (at > maxHistory) {\n      at = maxHistory;\n      history.splice(0, 1);\n    }\n  }\n  function handlePaste(event) {\n    if (event.defaultPrevented) return;\n    preventDefault(event);\n    const originalEvent = event.originalEvent ?? event;\n    const text = originalEvent.clipboardData.getData('text/plain').replace(/\\r\\n?/g, '\\n');\n    const pos = save();\n    insert(text);\n    doHighlight(editor);\n    restore({\n      start: Math.min(pos.start, pos.end) + text.length,\n      end: Math.min(pos.start, pos.end) + text.length,\n      dir: '<-'\n    });\n  }\n  function handleCut(event) {\n    const pos = save();\n    const selection = getSelection();\n    const originalEvent = event.originalEvent ?? event;\n    originalEvent.clipboardData.setData('text/plain', selection.toString());\n    document.execCommand('delete');\n    doHighlight(editor);\n    restore({\n      start: Math.min(pos.start, pos.end),\n      end: Math.min(pos.start, pos.end),\n      dir: '<-'\n    });\n    preventDefault(event);\n  }\n  function visit(editor, visitor) {\n    const queue = [];\n    if (editor.firstChild) queue.push(editor.firstChild);\n    let el = queue.pop();\n    while (el) {\n      if (visitor(el) === 'stop') break;\n      if (el.nextSibling) queue.push(el.nextSibling);\n      if (el.firstChild) queue.push(el.firstChild);\n      el = queue.pop();\n    }\n  }\n  function isCtrl(event) {\n    return event.metaKey || event.ctrlKey;\n  }\n  function isUndo(event) {\n    return isCtrl(event) && !event.shiftKey && getKeyCode(event) === 'Z';\n  }\n  function isRedo(event) {\n    return isCtrl(event) && event.shiftKey && getKeyCode(event) === 'Z';\n  }\n  function isCopy(event) {\n    return isCtrl(event) && getKeyCode(event) === 'C';\n  }\n  function getKeyCode(event) {\n    let key = event.key || event.keyCode || event.which;\n    if (!key) return undefined;\n    return (typeof key === 'string' ? key : String.fromCharCode(key)).toUpperCase();\n  }\n  function insert(text) {\n    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#039;');\n    document.execCommand('insertHTML', false, text);\n  }\n  function debounce(cb, wait) {\n    let timeout = 0;\n    return (...args) => {\n      clearTimeout(timeout);\n      timeout = window.setTimeout(() => cb(...args), wait);\n    };\n  }\n  function findPadding(text) {\n    // Find beginning of previous line.\n    let i = text.length - 1;\n    while (i >= 0 && text[i] !== '\\n') i--;\n    i++;\n    // Find padding of the line.\n    let j = i;\n    while (j < text.length && /[ \\t]/.test(text[j])) j++;\n    return [text.substring(i, j) || '', i, j];\n  }\n  function toString() {\n    return editor.textContent || '';\n  }\n  function preventDefault(event) {\n    event.preventDefault();\n  }\n  function getSelection() {\n    if (editor.parentNode?.nodeType == Node.DOCUMENT_FRAGMENT_NODE) {\n      return editor.parentNode.getSelection();\n    }\n    return window.getSelection();\n  }\n  return {\n    updateOptions(newOptions) {\n      Object.assign(options, newOptions);\n    },\n    updateCode(code) {\n      editor.textContent = code;\n      doHighlight(editor);\n      onUpdate(code);\n    },\n    onUpdate(callback) {\n      onUpdate = callback;\n    },\n    toString,\n    save,\n    restore,\n    recordHistory,\n    destroy() {\n      for (let [type, fn] of listeners) {\n        editor.removeEventListener(type, fn);\n      }\n    }\n  };\n}","map":{"version":3,"names":["globalWindow","window","CodeJar","editor","highlight","opt","options","tab","indentOn","moveToNewLine","spellcheck","catchTab","preserveIdent","addClosing","history","document","listeners","at","focus","onUpdate","prev","setAttribute","style","outline","overflowWrap","overflowY","whiteSpace","doHighlight","pos","isLegacy","contentEditable","debounceHighlight","debounce","save","restore","recording","shouldRecord","event","isUndo","isRedo","key","startsWith","debounceRecordHistory","recordHistory","on","type","fn","push","addEventListener","defaultPrevented","toString","handleNewLine","legacyNewLineFix","handleTabCharacters","handleSelfClosingCharacters","handleUndoRedo","isCopy","isComposing","_event","handlePaste","handleCut","s","getSelection","start","end","dir","undefined","anchorNode","anchorOffset","focusNode","focusOffset","textContent","length","nodeType","Node","ELEMENT_NODE","node","createTextNode","insertBefore","childNodes","visit","el","TEXT_NODE","nodeValue","normalize","startNode","startOffset","endNode","endOffset","current","len","startEl","uneditable","parentNode","endEl","setBaseAndExtent","getAttribute","beforeCursor","r0","getRangeAt","r","createRange","selectNodeContents","setEnd","startContainer","afterCursor","setStart","endContainer","before","after","padding","findPadding","newLinePadding","test","preventDefault","stopPropagation","insert","open","close","includes","wrapText","text","indexOf","shiftKey","Math","min","execCommand","record","innerHTML","html","lastRecord","splice","maxHistory","originalEvent","clipboardData","getData","replace","selection","setData","visitor","queue","firstChild","pop","nextSibling","isCtrl","metaKey","ctrlKey","getKeyCode","keyCode","which","String","fromCharCode","toUpperCase","cb","wait","timeout","args","clearTimeout","setTimeout","i","j","substring","DOCUMENT_FRAGMENT_NODE","updateOptions","newOptions","Object","assign","updateCode","code","callback","destroy","removeEventListener"],"sources":["/Users/peluche/Documents/NoursStuffs/CerisePeyi/dev/2k24/last/vendure-one-click-deploy/node_modules/codejar/dist/codejar.js"],"sourcesContent":["const globalWindow = window;\nexport function CodeJar(editor, highlight, opt = {}) {\n    const options = {\n        tab: '\\t',\n        indentOn: /[({\\[]$/,\n        moveToNewLine: /^[)}\\]]/,\n        spellcheck: false,\n        catchTab: true,\n        preserveIdent: true,\n        addClosing: true,\n        history: true,\n        window: globalWindow,\n        ...opt,\n    };\n    const window = options.window;\n    const document = window.document;\n    const listeners = [];\n    const history = [];\n    let at = -1;\n    let focus = false;\n    let onUpdate = () => void 0;\n    let prev; // code content prior keydown event\n    editor.setAttribute('contenteditable', 'plaintext-only');\n    editor.setAttribute('spellcheck', options.spellcheck ? 'true' : 'false');\n    editor.style.outline = 'none';\n    editor.style.overflowWrap = 'break-word';\n    editor.style.overflowY = 'auto';\n    editor.style.whiteSpace = 'pre-wrap';\n    const doHighlight = (editor, pos) => {\n        highlight(editor, pos);\n    };\n    let isLegacy = false; // true if plaintext-only is not supported\n    if (editor.contentEditable !== 'plaintext-only')\n        isLegacy = true;\n    if (isLegacy)\n        editor.setAttribute('contenteditable', 'true');\n    const debounceHighlight = debounce(() => {\n        const pos = save();\n        doHighlight(editor, pos);\n        restore(pos);\n    }, 30);\n    let recording = false;\n    const shouldRecord = (event) => {\n        return !isUndo(event) && !isRedo(event)\n            && event.key !== 'Meta'\n            && event.key !== 'Control'\n            && event.key !== 'Alt'\n            && !event.key.startsWith('Arrow');\n    };\n    const debounceRecordHistory = debounce((event) => {\n        if (shouldRecord(event)) {\n            recordHistory();\n            recording = false;\n        }\n    }, 300);\n    const on = (type, fn) => {\n        listeners.push([type, fn]);\n        editor.addEventListener(type, fn);\n    };\n    on('keydown', event => {\n        if (event.defaultPrevented)\n            return;\n        prev = toString();\n        if (options.preserveIdent)\n            handleNewLine(event);\n        else\n            legacyNewLineFix(event);\n        if (options.catchTab)\n            handleTabCharacters(event);\n        if (options.addClosing)\n            handleSelfClosingCharacters(event);\n        if (options.history) {\n            handleUndoRedo(event);\n            if (shouldRecord(event) && !recording) {\n                recordHistory();\n                recording = true;\n            }\n        }\n        if (isLegacy && !isCopy(event))\n            restore(save());\n    });\n    on('keyup', event => {\n        if (event.defaultPrevented)\n            return;\n        if (event.isComposing)\n            return;\n        if (prev !== toString())\n            debounceHighlight();\n        debounceRecordHistory(event);\n        onUpdate(toString());\n    });\n    on('focus', _event => {\n        focus = true;\n    });\n    on('blur', _event => {\n        focus = false;\n    });\n    on('paste', event => {\n        recordHistory();\n        handlePaste(event);\n        recordHistory();\n        onUpdate(toString());\n    });\n    on('cut', event => {\n        recordHistory();\n        handleCut(event);\n        recordHistory();\n        onUpdate(toString());\n    });\n    function save() {\n        const s = getSelection();\n        const pos = { start: 0, end: 0, dir: undefined };\n        let { anchorNode, anchorOffset, focusNode, focusOffset } = s;\n        if (!anchorNode || !focusNode)\n            throw 'error1';\n        // If the anchor and focus are the editor element, return either a full\n        // highlight or a start/end cursor position depending on the selection\n        if (anchorNode === editor && focusNode === editor) {\n            pos.start = (anchorOffset > 0 && editor.textContent) ? editor.textContent.length : 0;\n            pos.end = (focusOffset > 0 && editor.textContent) ? editor.textContent.length : 0;\n            pos.dir = (focusOffset >= anchorOffset) ? '->' : '<-';\n            return pos;\n        }\n        // Selection anchor and focus are expected to be text nodes,\n        // so normalize them.\n        if (anchorNode.nodeType === Node.ELEMENT_NODE) {\n            const node = document.createTextNode('');\n            anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset]);\n            anchorNode = node;\n            anchorOffset = 0;\n        }\n        if (focusNode.nodeType === Node.ELEMENT_NODE) {\n            const node = document.createTextNode('');\n            focusNode.insertBefore(node, focusNode.childNodes[focusOffset]);\n            focusNode = node;\n            focusOffset = 0;\n        }\n        visit(editor, el => {\n            if (el === anchorNode && el === focusNode) {\n                pos.start += anchorOffset;\n                pos.end += focusOffset;\n                pos.dir = anchorOffset <= focusOffset ? '->' : '<-';\n                return 'stop';\n            }\n            if (el === anchorNode) {\n                pos.start += anchorOffset;\n                if (!pos.dir) {\n                    pos.dir = '->';\n                }\n                else {\n                    return 'stop';\n                }\n            }\n            else if (el === focusNode) {\n                pos.end += focusOffset;\n                if (!pos.dir) {\n                    pos.dir = '<-';\n                }\n                else {\n                    return 'stop';\n                }\n            }\n            if (el.nodeType === Node.TEXT_NODE) {\n                if (pos.dir != '->')\n                    pos.start += el.nodeValue.length;\n                if (pos.dir != '<-')\n                    pos.end += el.nodeValue.length;\n            }\n        });\n        editor.normalize(); // collapse empty text nodes\n        return pos;\n    }\n    function restore(pos) {\n        const s = getSelection();\n        let startNode, startOffset = 0;\n        let endNode, endOffset = 0;\n        if (!pos.dir)\n            pos.dir = '->';\n        if (pos.start < 0)\n            pos.start = 0;\n        if (pos.end < 0)\n            pos.end = 0;\n        // Flip start and end if the direction reversed\n        if (pos.dir == '<-') {\n            const { start, end } = pos;\n            pos.start = end;\n            pos.end = start;\n        }\n        let current = 0;\n        visit(editor, el => {\n            if (el.nodeType !== Node.TEXT_NODE)\n                return;\n            const len = (el.nodeValue || '').length;\n            if (current + len > pos.start) {\n                if (!startNode) {\n                    startNode = el;\n                    startOffset = pos.start - current;\n                }\n                if (current + len > pos.end) {\n                    endNode = el;\n                    endOffset = pos.end - current;\n                    return 'stop';\n                }\n            }\n            current += len;\n        });\n        if (!startNode)\n            startNode = editor, startOffset = editor.childNodes.length;\n        if (!endNode)\n            endNode = editor, endOffset = editor.childNodes.length;\n        // Flip back the selection\n        if (pos.dir == '<-') {\n            [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset];\n        }\n        {\n            // If nodes not editable, create a text node.\n            const startEl = uneditable(startNode);\n            if (startEl) {\n                const node = document.createTextNode('');\n                startEl.parentNode?.insertBefore(node, startEl);\n                startNode = node;\n                startOffset = 0;\n            }\n            const endEl = uneditable(endNode);\n            if (endEl) {\n                const node = document.createTextNode('');\n                endEl.parentNode?.insertBefore(node, endEl);\n                endNode = node;\n                endOffset = 0;\n            }\n        }\n        s.setBaseAndExtent(startNode, startOffset, endNode, endOffset);\n        editor.normalize(); // collapse empty text nodes\n    }\n    function uneditable(node) {\n        while (node && node !== editor) {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n                const el = node;\n                if (el.getAttribute('contenteditable') == 'false') {\n                    return el;\n                }\n            }\n            node = node.parentNode;\n        }\n    }\n    function beforeCursor() {\n        const s = getSelection();\n        const r0 = s.getRangeAt(0);\n        const r = document.createRange();\n        r.selectNodeContents(editor);\n        r.setEnd(r0.startContainer, r0.startOffset);\n        return r.toString();\n    }\n    function afterCursor() {\n        const s = getSelection();\n        const r0 = s.getRangeAt(0);\n        const r = document.createRange();\n        r.selectNodeContents(editor);\n        r.setStart(r0.endContainer, r0.endOffset);\n        return r.toString();\n    }\n    function handleNewLine(event) {\n        if (event.key === 'Enter') {\n            const before = beforeCursor();\n            const after = afterCursor();\n            let [padding] = findPadding(before);\n            let newLinePadding = padding;\n            // If last symbol is \"{\" ident new line\n            if (options.indentOn.test(before)) {\n                newLinePadding += options.tab;\n            }\n            // Preserve padding\n            if (newLinePadding.length > 0) {\n                preventDefault(event);\n                event.stopPropagation();\n                insert('\\n' + newLinePadding);\n            }\n            else {\n                legacyNewLineFix(event);\n            }\n            // Place adjacent \"}\" on next line\n            if (newLinePadding !== padding && options.moveToNewLine.test(after)) {\n                const pos = save();\n                insert('\\n' + padding);\n                restore(pos);\n            }\n        }\n    }\n    function legacyNewLineFix(event) {\n        // Firefox does not support plaintext-only mode\n        // and puts <div><br></div> on Enter. Let's help.\n        if (isLegacy && event.key === 'Enter') {\n            preventDefault(event);\n            event.stopPropagation();\n            if (afterCursor() == '') {\n                insert('\\n ');\n                const pos = save();\n                pos.start = --pos.end;\n                restore(pos);\n            }\n            else {\n                insert('\\n');\n            }\n        }\n    }\n    function handleSelfClosingCharacters(event) {\n        const open = `([{'\"`;\n        const close = `)]}'\"`;\n        if (open.includes(event.key)) {\n            preventDefault(event);\n            const pos = save();\n            const wrapText = pos.start == pos.end ? '' : getSelection().toString();\n            const text = event.key + wrapText + close[open.indexOf(event.key)];\n            insert(text);\n            pos.start++;\n            pos.end++;\n            restore(pos);\n        }\n    }\n    function handleTabCharacters(event) {\n        if (event.key === 'Tab') {\n            preventDefault(event);\n            if (event.shiftKey) {\n                const before = beforeCursor();\n                let [padding, start] = findPadding(before);\n                if (padding.length > 0) {\n                    const pos = save();\n                    // Remove full length tab or just remaining padding\n                    const len = Math.min(options.tab.length, padding.length);\n                    restore({ start, end: start + len });\n                    document.execCommand('delete');\n                    pos.start -= len;\n                    pos.end -= len;\n                    restore(pos);\n                }\n            }\n            else {\n                insert(options.tab);\n            }\n        }\n    }\n    function handleUndoRedo(event) {\n        if (isUndo(event)) {\n            preventDefault(event);\n            at--;\n            const record = history[at];\n            if (record) {\n                editor.innerHTML = record.html;\n                restore(record.pos);\n            }\n            if (at < 0)\n                at = 0;\n        }\n        if (isRedo(event)) {\n            preventDefault(event);\n            at++;\n            const record = history[at];\n            if (record) {\n                editor.innerHTML = record.html;\n                restore(record.pos);\n            }\n            if (at >= history.length)\n                at--;\n        }\n    }\n    function recordHistory() {\n        if (!focus)\n            return;\n        const html = editor.innerHTML;\n        const pos = save();\n        const lastRecord = history[at];\n        if (lastRecord) {\n            if (lastRecord.html === html\n                && lastRecord.pos.start === pos.start\n                && lastRecord.pos.end === pos.end)\n                return;\n        }\n        at++;\n        history[at] = { html, pos };\n        history.splice(at + 1);\n        const maxHistory = 300;\n        if (at > maxHistory) {\n            at = maxHistory;\n            history.splice(0, 1);\n        }\n    }\n    function handlePaste(event) {\n        if (event.defaultPrevented)\n            return;\n        preventDefault(event);\n        const originalEvent = event.originalEvent ?? event;\n        const text = originalEvent.clipboardData.getData('text/plain').replace(/\\r\\n?/g, '\\n');\n        const pos = save();\n        insert(text);\n        doHighlight(editor);\n        restore({\n            start: Math.min(pos.start, pos.end) + text.length,\n            end: Math.min(pos.start, pos.end) + text.length,\n            dir: '<-',\n        });\n    }\n    function handleCut(event) {\n        const pos = save();\n        const selection = getSelection();\n        const originalEvent = event.originalEvent ?? event;\n        originalEvent.clipboardData.setData('text/plain', selection.toString());\n        document.execCommand('delete');\n        doHighlight(editor);\n        restore({\n            start: Math.min(pos.start, pos.end),\n            end: Math.min(pos.start, pos.end),\n            dir: '<-',\n        });\n        preventDefault(event);\n    }\n    function visit(editor, visitor) {\n        const queue = [];\n        if (editor.firstChild)\n            queue.push(editor.firstChild);\n        let el = queue.pop();\n        while (el) {\n            if (visitor(el) === 'stop')\n                break;\n            if (el.nextSibling)\n                queue.push(el.nextSibling);\n            if (el.firstChild)\n                queue.push(el.firstChild);\n            el = queue.pop();\n        }\n    }\n    function isCtrl(event) {\n        return event.metaKey || event.ctrlKey;\n    }\n    function isUndo(event) {\n        return isCtrl(event) && !event.shiftKey && getKeyCode(event) === 'Z';\n    }\n    function isRedo(event) {\n        return isCtrl(event) && event.shiftKey && getKeyCode(event) === 'Z';\n    }\n    function isCopy(event) {\n        return isCtrl(event) && getKeyCode(event) === 'C';\n    }\n    function getKeyCode(event) {\n        let key = event.key || event.keyCode || event.which;\n        if (!key)\n            return undefined;\n        return (typeof key === 'string' ? key : String.fromCharCode(key)).toUpperCase();\n    }\n    function insert(text) {\n        text = text\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#039;');\n        document.execCommand('insertHTML', false, text);\n    }\n    function debounce(cb, wait) {\n        let timeout = 0;\n        return (...args) => {\n            clearTimeout(timeout);\n            timeout = window.setTimeout(() => cb(...args), wait);\n        };\n    }\n    function findPadding(text) {\n        // Find beginning of previous line.\n        let i = text.length - 1;\n        while (i >= 0 && text[i] !== '\\n')\n            i--;\n        i++;\n        // Find padding of the line.\n        let j = i;\n        while (j < text.length && /[ \\t]/.test(text[j]))\n            j++;\n        return [text.substring(i, j) || '', i, j];\n    }\n    function toString() {\n        return editor.textContent || '';\n    }\n    function preventDefault(event) {\n        event.preventDefault();\n    }\n    function getSelection() {\n        if (editor.parentNode?.nodeType == Node.DOCUMENT_FRAGMENT_NODE) {\n            return editor.parentNode.getSelection();\n        }\n        return window.getSelection();\n    }\n    return {\n        updateOptions(newOptions) {\n            Object.assign(options, newOptions);\n        },\n        updateCode(code) {\n            editor.textContent = code;\n            doHighlight(editor);\n            onUpdate(code);\n        },\n        onUpdate(callback) {\n            onUpdate = callback;\n        },\n        toString,\n        save,\n        restore,\n        recordHistory,\n        destroy() {\n            for (let [type, fn] of listeners) {\n                editor.removeEventListener(type, fn);\n            }\n        },\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}